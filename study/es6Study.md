# es6学习笔记

## 1. let 和 const 命令
+ for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
```javascript
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}   // 输出三次abc
```
### 1.1 不存在变量提升
+ var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。

### 1.2 暂时性死区
+ 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
+ ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
+ 在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”
```javascript
function bar(x = y, y = 2) {
  return [x, y];
}
bar(); // 报错
// 调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。
```
### 1.3 不允许重复声明
+ let不允许在相同作用域内，重复声明同一个变量。

### 1.4 为什么需要块级作用域
+ ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。
1. 内层变量可能会覆盖外层变量。
2. 用来计数的循环变量泄露为全局变量。
+ 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。

### 1.5块级作用域与函数声明
+ ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
+ 允许在块级作用域内声明函数。
+ 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
+ 同时，函数声明还会提升到所在的块级作用域的头部。

### 1.6const命令
+ const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。
+ 如果真的想将对象冻结，应该使用 **Object.freeze** 方法。
+ 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。
```javascript
var constantize = (obj) => {
    Object.freeze(obj);
    Object.key(obj).forEach( (key, i) => {
        if (typeof obj[key] === 'object') {
            constantize(obj[key]);
        }
    })
}
```

### 1.7 顶层对象的属性
+ var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。


## 2. 变量的解构赋值
### 2.1 数组解构赋值和变量解构赋值的区别
+ 数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

### 2.2 解构赋值的用途
1. 交换变量的值
```javascript
let x = 1;
let y = 2;
[x, y] = [y, x];
```

2. 从函数返回多个值。
```javascript
function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();
```

3. 函数参数的定义
```javascript
// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);
// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});
```

4. 提取JSON数据

5. 函数参数的默认值
+ 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。

6. 遍历Map结构

7. 输入模块的指定方法
```javascript
const { SourceMapConsumer, SourceNode } = require("source-map");
```



```javascript

```
